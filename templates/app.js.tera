<script type="module">
let db;
let loadingSteps = {};

function updateLoadingStep(id, status, message) {
  if (!loadingSteps[id]) {
    const stepDiv = document.createElement('div');
    stepDiv.id = `step-${id}`;
    stepDiv.className = 'loading-step';
    document.getElementById('loadingSteps').appendChild(stepDiv);
    loadingSteps[id] = stepDiv;
  }

  const stepDiv = loadingSteps[id];
  stepDiv.className = `loading-step ${status}`;

  const icon = status === 'active' ? '⏳' : status === 'success' ? '✓' : status === 'error' ? '✗' : '';
  stepDiv.textContent = `${icon} ${message}`;
}

function setTableStatus(tableId, status, message) {
  const statusEl = document.getElementById(`${tableId}Status`);
  if (statusEl) {
    statusEl.className = `status-indicator ${status}`;
    const icon = status === 'loading' ? '⏳' : status === 'success' ? '✓' : status === 'error' ? '✗' : '';
    statusEl.textContent = message ? `${icon} ${message}` : icon;
  }
}

function showQueryError(tableId, errorMessage) {
  const errorEl = document.getElementById(`${tableId}Error`);
  if (errorEl) {
    errorEl.innerHTML = `<strong>Query Error:</strong> ${errorMessage}`;
    errorEl.classList.add('visible');
  }
}

function hideQueryError(tableId) {
  const errorEl = document.getElementById(`${tableId}Error`);
  if (errorEl) {
    errorEl.classList.remove('visible');
    errorEl.innerHTML = '';
  }
}

function showError(title, message, details) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-details';
  errorDiv.innerHTML = `
    <h3>${title}</h3>
    <p>${message}</p>
    ${details ? `<pre>${details}</pre>` : ''}
  `;
  document.querySelector('.loading-content').appendChild(errorDiv);
}

async function initDuckDB() {
  updateLoadingStep('import', 'active', 'Loading DuckDB WASM module...');

  let duckdb;
  try {
    duckdb = await import('https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.32.0/+esm');
    updateLoadingStep('import', 'success', 'DuckDB WASM module loaded');
  } catch (err) {
    updateLoadingStep('import', 'error', 'Failed to load DuckDB WASM module');
    throw new Error(`Failed to import DuckDB WASM: ${err.message}`);
  }

  updateLoadingStep('init', 'active', 'Initializing DuckDB...');

  try {
    const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
    const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);

    const worker_url = URL.createObjectURL(
      new Blob([`importScripts("${bundle.mainWorker}");`], {type: "text/javascript"})
    );

    const worker = new Worker(worker_url);
    const logger = new duckdb.ConsoleLogger();
    db = new duckdb.AsyncDuckDB(logger, worker);
    await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
    URL.revokeObjectURL(worker_url);

    updateLoadingStep('init', 'success', 'DuckDB initialized');
  } catch (err) {
    updateLoadingStep('init', 'error', 'Failed to initialize DuckDB');
    throw new Error(`Failed to initialize DuckDB: ${err.message}`);
  }

  // Register parquet files in DuckDB's file system
  const files = [
    { name: 'drivers.parquet', id: 'drivers' },
    { name: 'releases.parquet', id: 'releases' },
    { name: 'libraries.parquet', id: 'libraries' },
    { name: 'symbols.parquet', id: 'symbols' }
  ];

  for (const file of files) {
    updateLoadingStep(`fetch-${file.name}`, 'active', `Fetching ${file.name}...`);
    try {
      const response = await fetch(file.name);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const buffer = await response.arrayBuffer();
      await db.registerFileBuffer(file.name, new Uint8Array(buffer));

      const sizeKB = (buffer.byteLength / 1024).toFixed(1);
      updateLoadingStep(`fetch-${file.name}`, 'success', `${file.name} loaded (${sizeKB} KB)`);

      // Update download link with file size
      const sizeEl = document.getElementById(`size-${file.id}`);
      if (sizeEl) {
        sizeEl.textContent = `${sizeKB} KB`;
      }
    } catch (err) {
      updateLoadingStep(`fetch-${file.name}`, 'error', `Failed to load ${file.name}`);

      // Update download link with error
      const sizeEl = document.getElementById(`size-${file.id}`);
      if (sizeEl) {
        sizeEl.textContent = 'Error loading';
        sizeEl.style.color = '#dc3545';
      }

      throw new Error(`Failed to fetch ${file.name}: ${err.message}`);
    }
  }
}

function convertBigIntsToNumbers(obj) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'bigint') {
      // Convert BigInt to Number for JavaScript compatibility
      result[key] = Number(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

async function queryDuckDB(sql, context) {
  let conn;
  try {
    conn = await db.connect();
    const result = await conn.query(sql);
    const data = result.toArray().map(row => convertBigIntsToNumbers(Object.fromEntries(Object.entries(row))));
    return data;
  } catch (err) {
    console.error(`Query failed [${context}]:`, err);
    throw new Error(`Query failed: ${err.message}`);
  } finally {
    if (conn) {
      try {
        await conn.close();
      } catch (e) {
        console.warn('Failed to close connection:', e);
      }
    }
  }
}

let driversGrid = null;

async function loadDriversTable(customSQL) {
  console.log('loadDriversTable called with customSQL:', customSQL);
  setTableStatus('drivers', 'loading', 'Loading...');
  hideQueryError('drivers');

  try {
    const sql = customSQL || document.getElementById('driversQuery').value;
    console.log('Executing SQL:', sql);
    const data = await queryDuckDB(sql, 'drivers');
    console.log('Query returned', data?.length, 'rows');

    if (!data || data.length === 0) {
      setTableStatus('drivers', 'error', 'No data');
      showQueryError('drivers', 'Query returned no results');
      if (driversGrid) {
        driversGrid.destroy();
        driversGrid = null;
      }
      return;
    }

    // Dynamically create column definitions from the data
    const columnDefs = Object.keys(data[0]).map(key => ({
      field: key,
      headerName: key,
      filter: true,
      sortable: true,
      flex: 1,
      minWidth: 100
    }));

    const gridOptions = {
      columnDefs: columnDefs,
      rowData: data,
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: true
      },
      pagination: true,
      paginationPageSize: 20,
    };

    // Destroy existing grid before creating new one
    if (driversGrid) {
      driversGrid.destroy();
    }

    driversGrid = agGrid.createGrid(document.getElementById('driversGrid'), gridOptions);

    setTableStatus('drivers', 'success', `${data.length} rows`);

    // Update stats card
    const statEl = document.getElementById('stat-drivers');
    if (statEl) {
      statEl.textContent = data.length;
    }
  } catch (err) {
    console.error('Failed to load drivers table:', err);
    setTableStatus('drivers', 'error', err.message);
    showQueryError('drivers', err.message);
    if (driversGrid) {
      driversGrid.destroy();
      driversGrid = null;
    }
  }
}

async function runDriversQuery() {
  console.log('Running drivers query...');
  const queryText = document.getElementById('driversQuery').value;
  console.log('Query:', queryText);
  await loadDriversTable();
  updateURL();
}

let releasesGrid = null;

async function loadReleasesTable(customSQL) {
  setTableStatus('releases', 'loading', 'Loading...');
  hideQueryError('releases');

  try {
    const sql = customSQL || document.getElementById('releasesQuery').value;
    const data = await queryDuckDB(sql, 'releases');

    if (!data || data.length === 0) {
      setTableStatus('releases', 'error', 'No data');
      showQueryError('releases', 'Query returned no results');
      if (releasesGrid) {
        releasesGrid.destroy();
        releasesGrid = null;
      }
      return;
    }

    // Dynamically create column definitions from the data
    const columnDefs = Object.keys(data[0]).map(key => ({
      field: key,
      headerName: key,
      filter: true,
      sortable: true,
      flex: 1,
      minWidth: 100,
      cellRenderer: (params) => {
        // Handle null/undefined values
        if (params.value === null || params.value === undefined) {
          return '';
        }
        // Auto-link URL fields
        if (key.includes('url') && typeof params.value === 'string' && params.value.startsWith('http')) {
          const link = document.createElement('a');
          link.href = params.value;
          link.target = '_blank';
          link.textContent = params.value;
          return link;
        }
        // Format array fields
        if (Array.isArray(params.value)) {
          return params.value.join(', ');
        }
        return String(params.value);
      }
    }));

    const gridOptions = {
      columnDefs: columnDefs,
      rowData: data,
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: true
      },
      pagination: true,
      paginationPageSize: 50,
    };

    // Destroy existing grid before creating new one
    if (releasesGrid) {
      releasesGrid.destroy();
    }

    releasesGrid = agGrid.createGrid(document.getElementById('releasesGrid'), gridOptions);

    setTableStatus('releases', 'success', `${data.length} rows`);

    // Update stats card
    const statEl = document.getElementById('stat-releases');
    if (statEl) {
      statEl.textContent = data.length;
    }
  } catch (err) {
    console.error('Failed to load releases table:', err);
    setTableStatus('releases', 'error', err.message);
    showQueryError('releases', err.message);
    if (releasesGrid) {
      releasesGrid.destroy();
      releasesGrid = null;
    }
  }
}

async function runReleasesQuery() {
  console.log('Running releases query...');
  const queryText = document.getElementById('releasesQuery').value;
  console.log('Query:', queryText);
  await loadReleasesTable();
  updateURL();
}

let librariesGrid = null;

async function loadLibrariesTable(customSQL) {
  setTableStatus('libraries', 'loading', 'Loading...');
  hideQueryError('libraries');

  try {
    const sql = customSQL || document.getElementById('librariesQuery').value;
    const data = await queryDuckDB(sql, 'libraries');

    if (!data || data.length === 0) {
      setTableStatus('libraries', 'error', 'No data');
      showQueryError('libraries', 'Query returned no results');
      if (librariesGrid) {
        librariesGrid.destroy();
        librariesGrid = null;
      }
      return;
    }

    // Dynamically create column definitions from the data
    const columnDefs = Object.keys(data[0]).map(key => ({
      field: key,
      headerName: key,
      filter: true,
      sortable: true,
      flex: 1,
      minWidth: 100,
      cellRenderer: (params) => {
        // Handle null/undefined values
        if (params.value === null || params.value === undefined) {
          return '';
        }
        // Auto-link URL fields
        if (typeof params.value === 'string' && params.value.startsWith('http')) {
          const link = document.createElement('a');
          link.href = params.value;
          link.target = '_blank';
          link.textContent = params.value;
          return link;
        }
        return String(params.value);
      }
    }));

    const gridOptions = {
      columnDefs: columnDefs,
      rowData: data,
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: true
      },
      pagination: true,
      paginationPageSize: 50,
    };

    // Destroy existing grid before creating new one
    if (librariesGrid) {
      librariesGrid.destroy();
    }

    librariesGrid = agGrid.createGrid(document.getElementById('librariesGrid'), gridOptions);

    setTableStatus('libraries', 'success', `${data.length} rows`);

    // Update stats card
    const statEl = document.getElementById('stat-libraries');
    if (statEl) {
      statEl.textContent = data.length;
    }
  } catch (err) {
    console.error('Failed to load libraries table:', err);
    setTableStatus('libraries', 'error', err.message);
    showQueryError('libraries', err.message);
    if (librariesGrid) {
      librariesGrid.destroy();
      librariesGrid = null;
    }
  }
}

async function runLibrariesQuery() {
  console.log('Running libraries query...');
  const queryText = document.getElementById('librariesQuery').value;
  console.log('Query:', queryText);
  await loadLibrariesTable();
  updateURL();
}

let symbolsGrid = null;

async function loadSymbolsTable(customSQL) {
  setTableStatus('symbols', 'loading', 'Loading...');
  hideQueryError('symbols');

  try {
    const sql = customSQL || document.getElementById('symbolsQuery').value;
    const data = await queryDuckDB(sql, 'symbols');

    if (!data || data.length === 0) {
      setTableStatus('symbols', 'error', 'No data');
      showQueryError('symbols', 'Query returned no results');
      if (symbolsGrid) {
        symbolsGrid.destroy();
        symbolsGrid = null;
      }
      return;
    }

    // Dynamically create column definitions from the data
    const columnDefs = Object.keys(data[0]).map(key => ({
      field: key,
      headerName: key,
      filter: true,
      sortable: true,
      flex: 1,
      minWidth: 100,
      cellRenderer: (params) => {
        // Handle null/undefined values
        if (params.value === null || params.value === undefined) {
          return '';
        }
        // Special rendering for boolean is_stub field
        if (key === 'is_stub' && typeof params.value === 'boolean') {
          return params.value ? '✓' : '✗';
        }
        return String(params.value);
      }
    }));

    const gridOptions = {
      columnDefs: columnDefs,
      rowData: data,
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: true
      },
      pagination: true,
      paginationPageSize: 100,
    };

    // Destroy existing grid before creating new one
    if (symbolsGrid) {
      symbolsGrid.destroy();
    }

    symbolsGrid = agGrid.createGrid(document.getElementById('symbolsGrid'), gridOptions);

    setTableStatus('symbols', 'success', `${data.length} rows`);

    // Update stats card
    const statEl = document.getElementById('stat-symbols');
    if (statEl) {
      statEl.textContent = data.length;
    }
  } catch (err) {
    console.error('Failed to load symbols table:', err);
    setTableStatus('symbols', 'error', err.message);
    showQueryError('symbols', err.message);
    if (symbolsGrid) {
      symbolsGrid.destroy();
      symbolsGrid = null;
    }
  }
}

async function runSymbolsQuery() {
  console.log('Running symbols query...');
  const queryText = document.getElementById('symbolsQuery').value;
  console.log('Query:', queryText);
  await loadSymbolsTable();
  updateURL();
}

// Expose query functions to global scope for inline onclick handlers
window.runDriversQuery = runDriversQuery;
window.runReleasesQuery = runReleasesQuery;
window.runLibrariesQuery = runLibrariesQuery;
window.runSymbolsQuery = runSymbolsQuery;

async function init() {
  const loadingOverlay = document.getElementById('loadingOverlay');
  const mainContent = document.getElementById('mainContent');

  try {
    // Check if AG Grid is loaded
    if (typeof agGrid === 'undefined') {
      throw new Error('AG Grid library failed to load. Check your internet connection or try refreshing the page.');
    }

    // Initialize DuckDB
    await initDuckDB();

    // Restore queries from URL before loading tables
    restoreQueriesFromURL();

    // Load all tables
    updateLoadingStep('tables', 'active', 'Loading tables...');

    const results = await Promise.allSettled([
      loadDriversTable(),
      loadReleasesTable(),
      loadLibrariesTable(),
      loadSymbolsTable(),
      loadGetinfoTable()
    ]);

    // Check for any failures
    const failures = results.filter(r => r.status === 'rejected');
    if (failures.length > 0) {
      updateLoadingStep('tables', 'error', `${failures.length} table(s) failed to load`);

      // Show detailed error for first failure
      const firstError = failures[0].reason;
      showError(
        'Failed to Load Tables',
        `${failures.length} of 5 tables failed to load. Please check the console for details.`,
        firstError.message
      );

      // Keep loading overlay visible to show the error
      return;
    } else {
      updateLoadingStep('tables', 'success', 'All tables loaded successfully');
    }

    // Hide loading overlay and show main content
    loadingOverlay.classList.add('hidden');
    mainContent.classList.remove('hidden');

    // Restore tab from URL
    restoreTabFromURL();

    // Add keyboard shortcuts for query execution (Enter to run, Shift+Enter for newline)
    document.getElementById('driversQuery').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        runDriversQuery();
      }
    });

    document.getElementById('releasesQuery').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        runReleasesQuery();
      }
    });

    document.getElementById('librariesQuery').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        runLibrariesQuery();
      }
    });

    document.getElementById('symbolsQuery').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        runSymbolsQuery();
      }
    });

  } catch (err) {
    console.error('Critical error during initialization:', err);
    updateLoadingStep('init-error', 'error', 'Initialization failed');

    showError(
      'Failed to Initialize Dashboard',
      'The dashboard could not be loaded. Please refresh the page or check the console for details.',
      err.message
    );

    // Keep loading overlay visible to show the error
  }
}

// URL synchronization functions
function updateURL() {
  const params = new URLSearchParams();

  // Get current tab
  const activeTab = document.querySelector('.tab-button.active');
  if (activeTab) {
    const tabName = activeTab.getAttribute('data-tab');
    if (tabName !== 'overview') { // Don't add default tab to URL
      params.set('tab', tabName);
    }
  }

  // Get all query values
  const queryIds = ['driversQuery', 'releasesQuery', 'librariesQuery', 'symbolsQuery'];
  const defaultQueries = {
    'driversQuery': "SELECT * FROM read_parquet('drivers.parquet')",
    'releasesQuery': "SELECT * FROM read_parquet('releases.parquet')",
    'librariesQuery': "SELECT * FROM read_parquet('libraries.parquet')",
    'symbolsQuery': "SELECT * FROM read_parquet('symbols.parquet')"
  };

  queryIds.forEach(id => {
    const element = document.getElementById(id);
    if (element && element.value !== defaultQueries[id]) {
      console.log(`Adding query to URL: ${id}`, element.value);
      params.set(id, element.value);
    }
  });

  // Update URL without reloading page
  const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
  console.log('Updating URL to:', newURL);
  window.history.replaceState({}, '', newURL);
}

function restoreQueriesFromURL() {
  const params = new URLSearchParams(window.location.search);

  // Restore queries
  const queryIds = ['driversQuery', 'releasesQuery', 'librariesQuery', 'symbolsQuery'];
  queryIds.forEach(id => {
    const value = params.get(id);
    if (value) {
      const element = document.getElementById(id);
      if (element) {
        element.value = value;
      }
    }
  });
}

function restoreTabFromURL() {
  const params = new URLSearchParams(window.location.search);

  // Restore tab
  const tab = params.get('tab');
  if (tab) {
    switchTab(tab);
  }
}

// Tab switching functionality
function switchTab(tabName) {
  // Hide all tab contents
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });

  // Deactivate all tab buttons
  document.querySelectorAll('.tab-button').forEach(button => {
    button.classList.remove('active');
  });

  // Show selected tab content
  const tabContent = document.getElementById(`tab-${tabName}`);
  if (tabContent) {
    tabContent.classList.add('active');
  }

  // Activate selected tab button
  const tabButton = document.querySelector(`[data-tab="${tabName}"]`);
  if (tabButton) {
    tabButton.classList.add('active');
  }

  // Update URL
  updateURL();
}

// Setup tab click handlers
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
      const tabName = button.getAttribute('data-tab');
      switchTab(tabName);
    });
  });
});

// Global error handler for unhandled errors
window.addEventListener('error', (event) => {
  console.error('Unhandled error:', event.error);
  showError(
    'Unexpected Error',
    'An unexpected error occurred while loading the dashboard.',
    event.error ? event.error.message : event.message
  );
});

// Global handler for unhandled promise rejections
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  showError(
    'Unexpected Error',
    'An unexpected error occurred while loading the dashboard.',
    event.reason ? event.reason.message : String(event.reason)
  );
});

// Start initialization
init();
</script>
